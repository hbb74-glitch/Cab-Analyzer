cd Cab-Analyzer-main
git apply - <<'PATCH'
diff --git a/client/src/lib/tasteStore.ts b/client/src/lib/tasteStore.ts
index 8b6e3c1..b9d7f2a 100644
--- a/client/src/lib/tasteStore.ts
+++ b/client/src/lib/tasteStore.ts
@@ -27,6 +27,12 @@ export function makeTasteKey(ctx: TasteContext): string {
   return `${ctx.speakerPrefix}__${ctx.mode}__${ctx.intent}`;
 }
 
+// Shared baseline model key (learns general taste across intents).
+// Not exposed as a TasteIntent so the UI can't treat it as a selectable intent.
+function makeGlobalTasteKey(ctx: TasteContext): string {
+  return `${ctx.speakerPrefix}__${ctx.mode}__global`;
+}
+
 export function loadState(): StoreState {
   try {
     const raw = localStorage.getItem(STORAGE_KEY);
@@ -95,14 +101,22 @@ function dot(w: number[], x: number[]): number {
 }
 
 export function getTasteBias(ctx: TasteContext, x: number[]): { bias: number; confidence: number } {
   const state = loadState();
-  const key = makeTasteKey(ctx);
-  const model = state.models[key];
-  if (!model) return { bias: 0, confidence: 0 };
-
-  const bias = dot(model.w, x);
-  const confidence = clamp(model.nVotes / 30, 0, 1);
-  return { bias, confidence };
+  const keyIntent = makeTasteKey(ctx);
+  const keyGlobal = makeGlobalTasteKey(ctx);
+  const modelIntent = state.models[keyIntent];
+  const modelGlobal = state.models[keyGlobal];
+
+  // Shared + delta model:
+  // bias = dot(w_intent + 0.35*w_global, x)
+  // Confidence shown to UI remains intent-specific so Lead/Rhythm/Clean diverge clearly.
+  if (!modelIntent && !modelGlobal) return { bias: 0, confidence: 0 };
+
+  let bias = 0;
+  if (modelGlobal) bias += 0.35 * dot(modelGlobal.w, x); // baseline influence
+  if (modelIntent) bias += dot(modelIntent.w, x);        // intent delta
+
+  const confidence = clamp((modelIntent?.nVotes ?? 0) / 30, 0, 1);
+  return { bias, confidence };
 }
 
 export function meanVector(vectors: number[][]): number[] {
@@ -198,16 +212,25 @@ export function recordOutcome(
   xA: number[],
   xB: number[],
   outcome: VoteOutcome,
   opts?: { lr?: number; pairKey?: string; source?: VoteSource; tagsA?: string[]; tagsB?: string[] }
 ) {
   const state = loadState();
-  const key = makeTasteKey(ctx);
+  const keyIntent = makeTasteKey(ctx);
+  const keyGlobal = makeGlobalTasteKey(ctx);
   const wSrc = sourceWeight(opts?.source);
+  const dim = Math.min(xA.length, xB.length);
+
+  const ensureModels = () => {
+    getOrCreateModel(state, keyIntent, dim);
+    getOrCreateModel(state, keyGlobal, dim);
+  };
+
+  const bumpVotes = (incIntent: number, incGlobal: number) => {
+    ensureModels();
+    state.models[keyIntent].nVotes += incIntent;
+    state.models[keyGlobal].nVotes += incGlobal;
+    saveState(state);
+  };
 
   if (outcome === "tie") {
-    const dim = Math.min(xA.length, xB.length);
-    const model = getOrCreateModel(state, key, dim);
-    model.nVotes += 0.25 * wSrc;
-    saveState(state);
+    // Tie teaches weakly: intent + baseline counters.
+    bumpVotes(0.25 * wSrc, 0.10 * wSrc);
     return;
   }
 
   if (outcome === "both") {
     const pk = opts?.pairKey;
     if (pk) {
-      if (!state.complements[key]) state.complements[key] = {};
-      state.complements[key][pk] = (state.complements[key][pk] ?? 0) + 1;
+      // Complements are intent-specific (pairing differs by rhythm/lead/clean).
+      if (!state.complements[keyIntent]) state.complements[keyIntent] = {};
+      state.complements[keyIntent][pk] = (state.complements[keyIntent][pk] ?? 0) + 1;
     }
-    const dim = Math.min(xA.length, xB.length);
-    const model = getOrCreateModel(state, key, dim);
-    model.nVotes += 0.15 * wSrc;
-    saveState(state);
+    bumpVotes(0.15 * wSrc, 0.06 * wSrc);
     return;
   }
 
-  const baseLr = opts?.lr ?? 0.06;
-  const lr = baseLr * wSrc;
-  if (outcome === "a") recordPreference(ctx, xA, xB, { lr });
-  else if (outcome === "b") recordPreference(ctx, xB, xA, { lr });
+  const baseLr = opts?.lr ?? 0.06;
+  const lrIntent = baseLr * wSrc;        // intent delta learns faster
+  const lrGlobal = baseLr * wSrc * 0.35; // baseline learns slower
+
+  ensureModels();
+  const winner = outcome === "a" ? xA : xB;
+  const loser  = outcome === "a" ? xB : xA;
+
+  // Intent update
+  for (let i = 0; i < dim; i++) {
+    state.models[keyIntent].w[i] += lrIntent * (winner[i] - loser[i]);
+  }
+  state.models[keyIntent].nVotes += 1;
+
+  // Baseline update
+  for (let i = 0; i < dim; i++) {
+    state.models[keyGlobal].w[i] += lrGlobal * (winner[i] - loser[i]);
+  }
+  state.models[keyGlobal].nVotes += 1;
+
+  saveState(state);
 
   if (opts?.source === "learning") {
     const tagScale = 0.08 * wSrc;
     const tagsA = opts?.tagsA ?? [];
     const tagsB = opts?.tagsB ?? [];
@@ -242,10 +265,19 @@ export function recordOutcome(
 
     const xA2 = applyDeltaToVector(xA, deltaA, tagScale);
     const xB2 = applyDeltaToVector(xB, deltaB, tagScale);
 
-    if (outcome === "a") recordPreference(ctx, xA2, xB2, { lr: lr * 0.5 });
-    else if (outcome === "b") recordPreference(ctx, xB2, xA2, { lr: lr * 0.5 });
+    ensureModels();
+    const w2 = outcome === "a" ? xA2 : xB2;
+    const l2 = outcome === "a" ? xB2 : xA2;
+
+    // Tag-informed refinement: stronger on intent, lighter on baseline.
+    for (let i = 0; i < dim; i++) {
+      state.models[keyIntent].w[i] += (lrIntent * 0.5) * (w2[i] - l2[i]);
+      state.models[keyGlobal].w[i] += (lrGlobal * 0.25) * (w2[i] - l2[i]);
+    }
+    saveState(state);
   }
 }
 
 export function getComplementBoost(ctx: TasteContext, pairKey: string): number {
   const state = loadState();
   const key = makeTasteKey(ctx);
@@ -260,12 +292,16 @@ export function resetTaste(ctx?: TasteContext) {
   if (!ctx) {
     saveState(DEFAULT_STATE);
     return;
   }
-  const key = makeTasteKey(ctx);
-  delete state.models[key];
-  delete state.complements[key];
+  const keyIntent = makeTasteKey(ctx);
+  delete state.models[keyIntent];
+  delete state.complements[keyIntent];
+  // Note: intentionally NOT clearing the global baseline when clearing one intent.
+  // If you want a full reset for this speaker/mode baseline too, uncomment:
+  // delete state.models[makeGlobalTasteKey(ctx)];
   saveState(state);
 }
PATCH