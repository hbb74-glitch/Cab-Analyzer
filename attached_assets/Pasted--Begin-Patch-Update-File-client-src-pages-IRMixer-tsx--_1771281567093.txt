*** Begin Patch
*** Update File: client/src/pages/IRMixer.tsx
@@
-    // ------------------------------------------------------------
-    // AM4-friendly intelligent 4-candidate selection:
-    //  - 2x Top score (best)
-    //  - 1x Boundary (closest score to #2, i.e., most uncertain vs runner-up)
-    //  - 1x Diversity (least similar to selected set)
-    // ------------------------------------------------------------
+    // ------------------------------------------------------------
+    // AM4-friendly 4-pick selection (STRONGER DIVERSITY / LESS CLUSTERING)
+    // Your feedback: picks are too clustered. So we switch to MMR selection:
+    //   pick next = maximize:  λ * score  -  (1-λ) * maxSimilarityToSelected
+    // This forces diversity while still respecting score.
+    // ------------------------------------------------------------
     const cosineSim = (a: number[], b: number[]): number => {
       const n = Math.min(a.length, b.length);
       let dot = 0, na = 0, nb = 0;
       for (let i = 0; i < n; i++) {
         const x = Number.isFinite(a[i]) ? a[i] : 0;
         const y = Number.isFinite(b[i]) ? b[i] : 0;
         dot += x * y;
         na += x * x;
         nb += y * y;
       }
       const den = Math.sqrt(na) * Math.sqrt(nb);
       if (den < 1e-9) return 0;
       return dot / den; // -1..1
     };
 
     const keyOf = (p: any): string => {
       const ratio = p.suggestedRatio?.base ?? 0.5;
       return `${p.baseFilename}__${p.featureFilename}__${ratio}`;
     };
 
     const vecOf = (p: any): number[] | null => {
       const ratio = p.suggestedRatio?.base ?? 0.5;
       const k = `${p.baseFilename}__${p.featureFilename}__${ratio}`;
       const xRaw = vecByKey.get(k);
       if (!xRaw) return null;
       return centerVector(xRaw, mean);
     };
 
-    const selected: any[] = [];
-    const used = new Set<string>();
-    const add = (p: any) => {
-      const k = keyOf(p);
-      if (used.has(k)) return;
-      used.add(k);
-      selected.push(p);
-    };
-
-    // 1) Top 2 by score
-    if (rescored[0]) add(rescored[0]);
-    if (rescored[1]) add(rescored[1]);
-
-    // 2) Boundary: closest score to #2 among the next candidates
-    // (most informative "near-decision" comparison)
-    const runnerUpScore = rescored[1]?.score ?? rescored[0]?.score ?? 0;
-    let boundary: any | null = null;
-    let bestGap = Number.POSITIVE_INFINITY;
-    for (let i = 2; i < Math.min(rescored.length, 30); i++) {
-      const p = rescored[i];
-      const k = keyOf(p);
-      if (used.has(k)) continue;
-      const gap = Math.abs((p.score ?? 0) - runnerUpScore);
-      if (gap < bestGap) {
-        bestGap = gap;
-        boundary = p;
-      }
-    }
-    if (boundary) add(boundary);
-
-    // 3) Diversity pick
-    let diverse: any | null = null;
-    let lowestSimilarity = Number.POSITIVE_INFINITY;
-
-    for (let i = 2; i < Math.min(rescored.length, 30); i++) {
-      const p = rescored[i];
-      const k = keyOf(p);
-      if (used.has(k)) continue;
-
-      const v = vecOf(p);
-      if (!v) continue;
-
-      let maxSimToSelected = -1;
-
-      for (const s of selected) {
-        const sv = vecOf(s);
-        if (!sv) continue;
-        const sim = cosineSim(v, sv);
-        if (sim > maxSimToSelected) maxSimToSelected = sim;
-      }
-
-      if (maxSimToSelected < lowestSimilarity) {
-        lowestSimilarity = maxSimToSelected;
-        diverse = p;
-      }
-    }
-
-    if (diverse) add(diverse);
-
-    // Fallback: if we couldn't fill 4 (e.g., missing vectors), fill by score
-    for (let i = 0; selected.length < 4 && i < rescored.length; i++) {
-      add(rescored[i]);
-    }
-
-    return selected.slice(0, 4).map((p, idx) => ({ ...p, rank: idx + 1 }));
+    // Work on a larger pool to find genuinely different options
+    const POOL_N = 60;
+    const pool = rescored.slice(0, Math.min(POOL_N, rescored.length));
+
+    const selected: any[] = [];
+    const used = new Set<string>();
+    const add = (p: any) => {
+      const k = keyOf(p);
+      if (used.has(k)) return false;
+      used.add(k);
+      selected.push(p);
+      return true;
+    };
+
+    // Always seed with the top scorer
+    if (pool[0]) add(pool[0]);
+
+    const maxSimToSelected = (cand: any): number => {
+      const v = vecOf(cand);
+      if (!v) return 1; // treat missing vectors as "very similar" so they won't be chosen for diversity
+      let maxSim = -1;
+      for (const s of selected) {
+        const sv = vecOf(s);
+        if (!sv) continue;
+        maxSim = Math.max(maxSim, cosineSim(v, sv));
+      }
+      return maxSim;
+    };
+
+    const pickMMR = (lambda: number): any | null => {
+      let best: any | null = null;
+      let bestVal = -Number.POSITIVE_INFINITY;
+      for (const cand of pool) {
+        if (used.has(keyOf(cand))) continue;
+        const sim = selected.length ? maxSimToSelected(cand) : 0;
+        const score = Number.isFinite(cand.score) ? cand.score : 0;
+        const val = lambda * score - (1 - lambda) * sim * 100; // similarity penalty scaled
+        if (val > bestVal) {
+          bestVal = val;
+          best = cand;
+        }
+      }
+      return best;
+    };
+
+    // Pick #2: strong diversity
+    const p2 = pickMMR(0.55);
+    if (p2) add(p2);
+
+    // Pick #3: boundary vs current best (closest score to #1 but not too similar)
+    const topScore = Number.isFinite(selected[0]?.score) ? selected[0].score : (pool[0]?.score ?? 0);
+    let boundary: any | null = null;
+    let bestGap = Number.POSITIVE_INFINITY;
+    for (const cand of pool) {
+      if (used.has(keyOf(cand))) continue;
+      const gap = Math.abs((cand.score ?? 0) - topScore);
+      const sim = selected.length ? maxSimToSelected(cand) : 0;
+      // require at least some diversity for boundary too
+      if (sim > 0.92) continue;
+      if (gap < bestGap) {
+        bestGap = gap;
+        boundary = cand;
+      }
+    }
+    if (boundary) add(boundary);
+
+    // Pick #4: diversity again (MMR)
+    const p4 = pickMMR(0.55);
+    if (p4) add(p4);
+
+    // Final fallback: fill by score if needed
+    for (const cand of pool) {
+      if (selected.length >= 4) break;
+      add(cand);
+    }
+
+    return selected.slice(0, 4).map((p, idx) => ({ ...p, rank: idx + 1 }));
 
   }, [
     pairingPool,
     activeProfiles,
     learnedProfile,
     evaluatedPairs,
     exposureCounts,
     featuresByFilename,
     tasteContext,
     tasteEnabled,
     tasteVersion
   ]);
*** End Patch