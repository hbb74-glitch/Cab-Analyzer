*** Begin Patch
*** Update File: client/src/pages/Analyzer.tsx
@@
 function applyContextBias(
   baseRole: string,
   tf: TonalFeatures,
   filename: string,
   speakerStats?: SpeakerStats
 ): string {
   const name = (filename || "").toLowerCase();
   const bp: any = (tf.bandsPercent ?? {});
 
   const centroid = Number(tf.spectralCentroidHz ?? 0);
   const ext = Number(tf.rolloffFreq ?? 0);
   const smooth = Number(tf.smoothScore ?? 0);
   const tilt = Number(tf.tiltDbPerOct ?? 0);
   const midPct = Number((bp.mid ?? 0) * 100);
   const highMidPct = Number((bp.highMid ?? 0) * 100);
   const presencePct = Number((bp.presence ?? 0) * 100);
   const hiMidMid = midPct > 0 ? (highMidPct / midPct) : 10;
 
   const zCentroid = speakerStats ? zScore(centroid, speakerStats.mean.centroid, speakerStats.std.centroid) : 0;
   const zExt = speakerStats ? zScore(ext, speakerStats.mean.ext, speakerStats.std.ext) : 0;
   const zPresence = speakerStats ? zScore(presencePct, speakerStats.mean.presence, speakerStats.std.presence) : 0;
   const zHiMidMid = speakerStats ? zScore(hiMidMid, speakerStats.mean.hiMidMid, speakerStats.std.hiMidMid) : 0;
 
+  // === HARD GUARDRAIL (musical sanity) ===
+  // A "Fizz Tamer" should NOT be presence-forward. If the shot is explicitly tagged "presence"
+  // or has meaningful 4–6k presence energy, do not allow Fizz Tamer to win unless it is clearly dark/rolled-off.
+  const isPresenceTagged = name.includes("presence");
+  const isClearlyDark = (ext > 0 && ext <= 3900) || (tilt <= -5.8);
+  if (baseRole === "Fizz Tamer" && (isPresenceTagged || presencePct >= 28) && !isClearlyDark) {
+    // Treat it as a forward/support layer rather than a tamer.
+    baseRole = "Cut Layer";
+  }
+
   const objectivelyCutty =
     (zCentroid >= 1.0 && zExt >= 0.8) ||
     (zPresence >= 1.1) ||
     (zHiMidMid >= 1.2);
 
   if (objectivelyCutty && baseRole === "Foundation") {
     return "Cut Layer";
   }
@@
   score[baseRole] += 3.0;
@@
   const sheenCandidate = smooth >= 88 && ext >= 5100 && presencePct <= 48 && hiMidMid <= 1.75 && tilt >= -5.2;
   if (sheenCandidate) score["Lead Polish"] += 0.9;
@@
   return best;
 }
@@
-  const collectionCoverage = useMemo(() => {
-    if (!batchPreferenceRoles || !learnedProfile || learnedProfile.status === "no_data") return null;
-    const total = batchPreferenceRoles.length;
-    const featureCount = batchPreferenceRoles.filter((r) => r.role === "Feature element").length;
-    const bodyCount = batchPreferenceRoles.filter((r) => r.role === "Body element").length;
-    const unlikelyCount = batchPreferenceRoles.filter((r) => r.unlikelyToUse).length;
-    const unmatched = total - featureCount - bodyCount;
-    const avgFeatured = featureCount > 0
-      ? Math.round(batchPreferenceRoles.filter((r) => r.role === "Feature element").reduce((s, r) => s + r.featuredScore, 0) / featureCount)
-      : 0;
-    const avgBody = bodyCount > 0
-      ? Math.round(batchPreferenceRoles.filter((r) => r.role === "Body element").reduce((s, r) => s + r.bodyScore, 0) / bodyCount)
-      : 0;
-
-    const minForRole = Math.max(2, Math.ceil(total * 0.15));
-    const hasEnoughFeature = featureCount >= minForRole;
-    const hasEnoughBody = bodyCount >= minForRole;
-
-    let verdict: string;
-    let verdictColor: string;
-    const suggestions: string[] = [];
-
-    if (hasEnoughFeature && hasEnoughBody) {
-      verdict = "Good coverage";
-      verdictColor = "text-emerald-400";
-      suggestions.push(`${featureCount} feature-type and ${bodyCount} body-type IRs give you solid blending range for your preferred tones.`);
-    } else if (!hasEnoughFeature && !hasEnoughBody) {
-      verdict = "Limited coverage";
-      verdictColor = "text-red-400";
-      suggestions.push("Few IRs match your preferred tonal profiles. Consider capturing more shots with varied mic positions.");
-      suggestions.push("For brighter/feature tones: try condenser or ribbon mics at cap or cap-edge positions.");
-      suggestions.push("For warmer/body tones: try dynamic mics at cone or edge positions, slightly off-axis.");
-    } else if (!hasEnoughFeature) {
-      verdict = "Needs more feature-type shots";
-      verdictColor = "text-amber-400";
-      suggestions.push(`Only ${featureCount} IR${featureCount !== 1 ? 's' : ''} lean toward the brighter, presence-forward character you tend to prefer in feature elements.`);
-      suggestions.push("Try cap or cap-edge positions with condensers or ribbons for more articulation and air.");
-    } else {
-      verdict = "Needs more body-type shots";
-      verdictColor = "text-amber-400";
-      suggestions.push(`Only ${bodyCount} IR${bodyCount !== 1 ? 's' : ''} lean toward the warmer, mid-forward character you prefer for foundation/body tones.`);
-      suggestions.push("Try cone or edge positions with dynamic mics for more weight and warmth.");
-    }
-
-    if (unlikelyCount > 0) {
-      suggestions.push(`${unlikelyCount} IR${unlikelyCount !== 1 ? 's' : ''} scored low against current preferences — these may still work well as standalone IRs or in different blend contexts.`);
-    }
-
-    return {
-      featureCount,
-      bodyCount,
-      unlikelyCount,
-      unmatched,
-      avgFeatured,
-      avgBody,
-      verdict,
-      verdictColor,
-      suggestions,
-      total,
-    };
-  }, [batchPreferenceRoles, learnedProfile]);
+  // Preference Coverage (UPDATED): use current musical-role taxonomy, not deprecated feature/body profiles.
+  const collectionCoverage = useMemo(() => {
+    if (!batchResult?.results?.length) return null;
+
+    const roles = batchResult.results.map((r: any) => {
+      const fn = String(r.filename ?? r.name ?? "");
+      const raw = String(r.musicalRole ?? r.musical_role ?? r.role ?? "");
+      if (raw) return raw;
+      try {
+        // Compute from the same path used in TSV export so panel matches exports.
+        const bandsFromBatch = {
+          subBass: ((Number(r.subBassPercent) || 0) / 100),
+          bass: ((Number(r.bassPercent) || 0) / 100),
+          lowMid: ((Number(r.lowMidPercent) || 0) / 100),
+          mid: ((Number(r.midPercent) || 0) / 100),
+          highMid: ((Number(r.highMidPercent) || 0) / 100),
+          presence: ((Number(r.presencePercent) || 0) / 100),
+          air: ((Number(r.airPercent) || 0) / 100),
+        };
+        const tf = computeTonalFeatures({ ...r, bandsPercent: bandsFromBatch });
+        const base = classifyMusicalRole(tf);
+        const spk = inferSpeakerIdFromFilename(fn);
+        const st = speakerStatsRef.current.get(spk);
+        return applyContextBias(base, tf, fn, st);
+      } catch {
+        return "";
+      }
+    });
+
+    const count = (x: string) => roles.filter((r) => r === x).length;
+    const total = roles.length;
+
+    const foundation = count("Foundation");
+    const cutLayer = count("Cut Layer");
+    const midThickener = count("Mid Thickener");
+    const leadPolish = count("Lead Polish");
+    const fizzTamer = count("Fizz Tamer");
+    const darkSpecialty = count("Dark Specialty");
+
+    const featureLayers = cutLayer + leadPolish;
+    const bodyLayers = foundation + midThickener;
+
+    const minForCategory = Math.max(2, Math.ceil(total * 0.15));
+    const hasBody = bodyLayers >= minForCategory;
+    const hasFeature = featureLayers >= minForCategory;
+    const hasPolish = leadPolish >= 1;
+    const hasTamer = fizzTamer >= 1;
+
+    let verdict = "Limited coverage";
+    let verdictColor = "text-red-400";
+    const suggestions: string[] = [];
+
+    if (hasBody && hasFeature && hasPolish) {
+      verdict = "Good coverage";
+      verdictColor = "text-emerald-400";
+      suggestions.push(`Strong spread: ${bodyLayers} body layers (Foundation + Mid Thickener) and ${featureLayers} feature layers (Cut + Polish).`);
+      if (!hasTamer) suggestions.push("Add 1–2 dedicated Fizz Tamers (low air, low fizz) for harsher amps/IR combos.");
+    } else if (!hasFeature) {
+      verdict = "Needs more feature layers";
+      verdictColor = "text-amber-400";
+      suggestions.push(`Only ${featureLayers} feature layers (Cut + Polish). Add more cap / CapEdge_Br cut shots and at least 1 extra Lead Polish.`);
+    } else if (!hasBody) {
+      verdict = "Needs more body layers";
+      verdictColor = "text-amber-400";
+      suggestions.push(`Only ${bodyLayers} body layers (Foundation + Thickener). Add more Cone / CapEdge_Dk / CapEdge_Cone_Tr and/or ribbon body shots.`);
+    } else if (!hasPolish) {
+      verdict = "Needs at least one polish layer";
+      verdictColor = "text-amber-400";
+      suggestions.push("Add at least 1 Lead Polish (high air_pct with smooth score) to finish mixes without harshness.");
+    }
+
+    if (darkSpecialty >= Math.max(3, Math.ceil(total * 0.25))) {
+      suggestions.push("Many Dark Specialty shots detected — balance with more Cut/Polish shots for versatility.");
+    }
+
+    return {
+      verdict,
+      verdictColor,
+      suggestions,
+      total,
+      featureLayers,
+      bodyLayers,
+      foundation,
+      cutLayer,
+      midThickener,
+      leadPolish,
+      fizzTamer,
+      darkSpecialty,
+    };
+  }, [batchResult]);
@@
-                        <span className="px-2 py-1 rounded bg-cyan-500/10 text-cyan-400 font-mono" data-testid="text-feature-count">
-                          {collectionCoverage.featureCount} feature-type
-                          {collectionCoverage.avgFeatured > 0 && ` (avg ${collectionCoverage.avgFeatured})`}
-                        </span>
-                        <span className="px-2 py-1 rounded bg-amber-500/10 text-amber-400 font-mono" data-testid="text-body-count">
-                          {collectionCoverage.bodyCount} body-type
-                          {collectionCoverage.avgBody > 0 && ` (avg ${collectionCoverage.avgBody})`}
-                        </span>
-                        {collectionCoverage.unmatched > 0 && (
-                          <span className="px-2 py-1 rounded bg-white/5 text-muted-foreground font-mono">
-                            {collectionCoverage.unmatched} unmatched
-                          </span>
-                        )}
-                        {collectionCoverage.unlikelyCount > 0 && (
-                          <span className="px-2 py-1 rounded bg-amber-500/10 text-amber-400 font-mono" data-testid="text-unlikely-count">
-                            {collectionCoverage.unlikelyCount} low match
-                          </span>
-                        )}
+                        <span className="px-2 py-1 rounded bg-cyan-500/10 text-cyan-400 font-mono" data-testid="text-feature-count">
+                          {collectionCoverage.featureLayers} feature layers
+                          <span className="text-muted-foreground"> (Cut {collectionCoverage.cutLayer}, Polish {collectionCoverage.leadPolish})</span>
+                        </span>
+                        <span className="px-2 py-1 rounded bg-amber-500/10 text-amber-400 font-mono" data-testid="text-body-count">
+                          {collectionCoverage.bodyLayers} body layers
+                          <span className="text-muted-foreground"> (Foundation {collectionCoverage.foundation}, Thick {collectionCoverage.midThickener})</span>
+                        </span>
+                        <span className="px-2 py-1 rounded bg-white/5 text-muted-foreground font-mono">
+                          Fizz Tamers {collectionCoverage.fizzTamer} • Dark {collectionCoverage.darkSpecialty}
+                        </span>
*** End Patch